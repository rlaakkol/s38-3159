#!/usr/bin/env python3

import argparse
import sys
import logging; log = logging.getLogger('ps-client')

import pubsub.args
import pubsub.client

def main (args):
    """
        Publish-Subscribe client.
    """

    parser = argparse.ArgumentParser(description=__doc__)

    pubsub.args.parser(parser)
    pubsub.logger.parser(parser, component='client')
    
    parser.add_argument('-s', '--server-ip', metavar='IP', required=True,
            help="Publish server address")
    parser.add_argument('-p', '--server-port', metavar='PORT', required=True,
            help="Publish server port")
    parser.add_argument('-L', '--list', action='store_true',
            help="Query for available sensors")
    parser.add_argument('-a', '--aggregate', metavar='AGGREGATE',
            help="The type of aggregation to use")
    parser.add_argument('-i', '--interval', metavar='INTERVAL', type=int,
            help="Aggregation interval")
    parser.add_argument('-S', '--step', metavar='STEP', type=int, 
            help="Aggregation step")
    parser.add_argument('--under', metavar='UNDER', 
            help="Minimum sensor value threshold")
    parser.add_argument('--over', metavar='OVER', 
            help="Maximum sensor value threshold")

    parser.add_argument('sensors', metavar='SENSOR', nargs='*',
            help="Sensors to subscribe to")

    args = parser.parse_args(args)

    # validate aggregation arguments
    if not args.aggregate and args.step:
        print('Error: -S/--step can only be used when the -a/--aggregate option' \
            ' is provided', file=sys.stderr)
        return 0
    
    pubsub.args.apply(args)
    loggers = pubsub.logger.apply(args)

    # client
    client = pubsub.client.Client(
            args.server_ip,
            args.server_port,
            loggers,
    )
    
    try:
        if args.list:
            # query
            for sensor in client.query():
                print(sensor)

        if not args.list or args.sensors:
            if args.sensors:
                if len(args.sensors) == 1 and (args.aggregate or args.interval
                    or args.under or args.over):
                    aggr = {}
                    if args.aggregate:
                        aggr['aggregate'] = args.aggregate
                    if args.interval:
                        aggr['interval'] = args.interval
                    if args.step:
                        aggr['step'] = args.step
                    if args.under:
                        aggr['under'] = args.under
                    if args.over:
                        aggr['over'] = args.over
                    sub = client.subscribe({args.sensors[0]: aggr})
                else:
                    sub = client.subscribe(args.sensors)
            else:
                sub = client.subscribe()

            # subscribe -> publish
            for type, id, update in sub:
                print("{type}\t{id}\t{value}".format(type=type, id=id, value=update[type]))

    except KeyboardInterrupt:
        log.error("exit on KeyboardInterrupt")
        return 0

    else:
        return 0

    finally:
        loggers.close()

if __name__ == '__main__':
    pubsub.args.main(main)
